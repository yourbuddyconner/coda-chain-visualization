{"version":3,"sources":["logo.svg","client.js","constants.js","transactions/transactions.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","cache","InMemoryCache","link","HttpLink","uri","ApolloClient","name","version","queryDeduplication","defaultOptions","watchQuery","fetchPolicy","useState","React","useRef","useEffect","GET_BLOCKS","useCallback","gql","DynamicGraph","nodes","links","data","setData","nodeIndex","setNodeIndex","linkIndex","setLinkIndex","useQuery","pollInterval","query_data","loading","error","fgRef","refetch","knownKeys","require","receivedTransactions","blocks","forEach","node","transactions","userCommands","command","key","from","to","transactionIds","push","id","totalFees","parseInt","fee","totalSent","amount","totalTransactions","target","source","recievedFeeTransfers","creator","feeTransfer","transfer","recipient","totalTransfers","observedKeys","Object","keys","map","txKey","tx","flat","newNodes","filter","item","pos","indexOf","publicKey","newLinks","values","newNode","index","length","ref","enableNodeDrag","nodeLabel","substring","linkCurvature","linkDirectionalArrowLength","linkWidth","nTx","linkColor","rainbow","Rainbow","setNumberRange","setSpectrum","colourAt","graphData","App","className","Boolean","window","location","hostname","match","ReactDOM","render","client","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"yLAAAA,EAAOC,QAAU,IAA0B,kC,iuUCO9BC,EAAQ,IAAIC,IACZC,EAAO,IAAIC,IAAS,CAC/BC,ICTwB,4CDYX,MAAIC,IAAa,CAE9BL,MAAOA,EACPE,KAAMA,EAGNI,KAAM,mBACNC,QAAS,MACTC,oBAAoB,EACpBC,eAAgB,CACdC,WAAY,CACVC,YAAa,wB,8gBEfXC,EAA6CC,IAA7CD,SAAqBE,GAAwBD,IAAnCE,UAAmCF,IAAxBC,QAsRvBE,GAtR+CH,IAAhBI,YAsRlBC,IAAH,MAsBDC,EA1SM,WAAO,IAAD,EACCP,EAAS,CAAEQ,MAAO,GAAIC,MAAO,KAD9B,mBAChBC,EADgB,KACVC,EADU,OAEWX,EAAS,CAAEQ,MAAO,GAAIC,MAAO,KAFxC,gCAGWT,EAAS,KAHpB,mBAGhBY,EAHgB,KAGLC,EAHK,OAOWb,EAAS,IAPpB,mBAOhBc,EAPgB,KAOLC,EAPK,OAW+BC,YAASZ,EAAY,CAACa,aAAc,MAA5DC,GAXP,EAWfC,QAXe,EAWNC,MAXM,EAWCV,MAClBW,GAZiB,EAWmBC,QAC5BpB,KAQRqB,EAAYC,EAAQ,KAEtBC,EAAuB,GACtBP,GACDA,EAAWQ,OAAOlB,MAAMmB,SAAQ,SAAAC,GAC5BA,EAAKC,aAAaC,aAAaH,SAAQ,SAAAI,GACnC,IAAIC,EAAMD,EAAQE,KAAOF,EAAQG,GAC5BF,KAAOP,GACRA,EAAqBO,GAAKG,eAAeC,KAAKL,EAAQM,IACtDZ,EAAqBO,GAAKM,WAAaC,SAASR,EAAQS,KACxDf,EAAqBO,GAAKS,WAAaF,SAASR,EAAQW,QACxDjB,EAAqBO,GAAKW,mBAAqB,GAG/ClB,EAAqBO,GAAO,CACxBK,GAAIL,EACJY,OAAQb,EAAQG,GAChBW,OAAQd,EAAQE,KAChBE,eAAgB,CAACJ,EAAQM,IACzBC,UAAWC,SAASR,EAAQS,KAC5BC,UAAWF,SAASR,EAAQW,QAC5BC,kBAAmB,SAMvC,IAAIG,EAAuB,GACtB5B,GACDA,EAAWQ,OAAOlB,MAAMmB,SAAQ,SAAAC,GAC5B,IAAImB,EAAUnB,EAAKmB,QACnBnB,EAAKC,aAAamB,YAAYrB,SAAQ,SAAAsB,GAClC,IAAIjB,EAAMe,EAAUE,EAASC,UACxBlB,KAAOc,GACRA,EAAqBd,GAAKM,WAAaC,SAASU,EAAST,KACzDM,EAAqBd,GAAKmB,gBAAkB,GAG5CL,EAAqBd,GAAO,CACxBM,UAAWC,SAASU,EAAST,KAC7BN,GAAIe,EAASC,UACbjB,KAAMc,EACNI,eAAgB,SAOpC,IAGMC,EAHOC,OAAOC,KAAK7B,GAGG8B,KAAI,SAACC,GAC7B,IAAIC,EAAKhC,EAAqB+B,GAC9B,MAAO,CAACC,EAAGZ,OAAQY,EAAGb,WACvBc,OAcGC,EAVcP,EAAaQ,QAAO,SAASC,EAAMC,GACnD,OAAOV,EAAaW,QAAQF,IAASC,KAKbF,QAAO,SAAC5B,GAChC,QAASA,KAAOpB,MAGK2C,KAAI,SAAAvB,GACzB,MAAO,CACHK,GAAIL,EACJtC,KAAM6B,EAAUS,GAChBgC,UAAWhC,MAObiC,EAFgBZ,OAAOa,OAAOzC,GAELmC,QAAO,SAACtE,GAEnC,QADYA,EAAKuD,OAASvD,EAAKsD,UACf9B,MA+HpB,OAvHK6C,GACDA,EAAShC,SAAQ,SAAAwC,GACbxD,GAAQ,YAAqB,IAAnBH,EAAkB,EAAlBA,MAAOC,EAAW,EAAXA,MAKb,OAJAI,GAAa,SAACuD,GAEV,OADAA,EAAMD,EAAQ9B,IAAM7B,EAAM6D,OACnBD,KAEJ,CACH5D,MAAM,GAAD,mBAAMA,GAAN,CAAa2D,IAClB1D,MAAOA,SAOlBwD,GACDA,EAAStC,SAAQ,SAAArC,GACRA,EAAKsD,UAAUhC,GAAatB,EAAKuD,UAAUjC,GAC5CD,GAAQ,YAAqB,IAAnBH,EAAkB,EAAlBA,MAAOC,EAAW,EAAXA,MAKb,OAJAM,GAAa,SAACqD,GAEV,OADAA,EAAM9E,EAAK+C,IAAM5B,EAAM4D,OAChBD,KAEJ,CACH5D,MAAOA,EACPC,MAAM,GAAD,mBAAMA,GAAN,CAAanB,WA6F/B,kBAAC,IAAD,CACPgF,IAAKjD,EACLkD,gBAAgB,EAChBC,UAAW,SAAC5C,GACR,MAAM,YAAN,OAAmBA,EAAKlC,KAAxB,uCACckC,EAAKoC,UAAUS,UAAU,EAAE,GADzC,eAaJC,cAAe,IACfC,2BAA4B,EAC5BC,UAAW,SAACtF,GACR,IAAMuF,EAAMvF,EAAKqD,kBACjB,OAAIkC,EAAM,EAAU,EAChBA,EAAM,GAAW,EACjBA,EAAM,GAAW,EACjBA,EAAM,GAAW,EACjBA,EAAM,IAAY,EAClBA,EAAM,IAAY,EAQf,IAEXC,UAAW,SAACxF,GACR,IACIyF,EAAU,IAAIC,IAGlB,OAFAD,EAAQE,eAAe,EAAG,KAC1BF,EAAQG,YAAY,OAAQ,QAAS,SAAU,SAAU,OAClD,IAAMH,EAAQI,SAAS7F,EAAKmD,YAEvC2C,UAAW1E,K,OCxQA2E,MAXf,WACE,OACE,yBAAKC,UAAU,OACb,kBAAC,EAAD,QCEcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCTNC,IAASC,OACP,kBAAC,IAAD,CAAgBC,OAAQA,GACtB,kBAAC,EAAD,OAEHC,SAASC,eAAe,SDoHnB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.8b2390e8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import { ApolloClient } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\n\nimport { DAEMON_URL } from './constants';\n\n// Instantiate required constructor fields\nexport const cache = new InMemoryCache();\nexport const link = new HttpLink({\n  uri: DAEMON_URL\n});\n\nexport default new ApolloClient({\n  // Provide required constructor fields\n  cache: cache,\n  link: link,\n\n  // Provide some optional constructor fields\n  name: 'react-web-client',\n  version: '1.3',\n  queryDeduplication: false,\n  defaultOptions: {\n    watchQuery: {\n      fetchPolicy: 'cache-and-network',\n    },\n  },\n});","export const DAEMON_URL = 'https://graphql-test.o1test.net/graphql'","import React from 'react';\nimport gql from 'graphql-tag';\nimport { useQuery } from '@apollo/react-hooks';\nimport { forOfStatement } from '@babel/types';\nimport { ForceGraph2D, ForceGraph3D } from 'react-force-graph';\nimport _ from \"lodash\";\nimport Rainbow from \"rainbowvis.js\"\n\nconst { useState, useEffect, useRef, useCallback } = React;\n\nconst DynamicGraph = () => {\n    const [data, setData] = useState({ nodes: [], links: [] });\n    const [graphData, setGraphData] = useState({ nodes: [], links: [] });\n    const [nodeIndex, setNodeIndex] = useState({})\n    //    [node.publicKey]: {\n    //        index: int\n    //    }\n    const [linkIndex, setLinkIndex] = useState({})\n    //    [tx.to + tx.from]: {\n    //        index: int\n    //    } \n    const { loading, error, data: query_data, refetch } = useQuery(GET_BLOCKS, {pollInterval: 10000});\n    const fgRef = useRef();\n    // filter out all the existing nodes\n    // call setData with the rest\n    //let receivedTransactions = query_data && query_data.blocks.nodes.map(node => node.transactions.userCommands).flat() || []\n\n    // maintain a second state which is a nice format of what nodes and links do you have now\n    // when you get data, you use the second state to compute which nodes/links are new\n    // then you update both the first (graph) and second state with the data \n    const knownKeys = require('../knownKeys.json');\n\n    let receivedTransactions = {};\n    if ( query_data ) { \n        query_data.blocks.nodes.forEach(node => {\n            node.transactions.userCommands.forEach(command => {\n                let key = command.from + command.to\n                if ( key in receivedTransactions ){\n                    receivedTransactions[key].transactionIds.push(command.id)\n                    receivedTransactions[key].totalFees += parseInt(command.fee)\n                    receivedTransactions[key].totalSent += parseInt(command.amount)\n                    receivedTransactions[key].totalTransactions += 1\n                }\n                else {\n                    receivedTransactions[key] = {\n                        id: key,\n                        target: command.to,\n                        source: command.from,\n                        transactionIds: [command.id],\n                        totalFees: parseInt(command.fee),\n                        totalSent: parseInt(command.amount),\n                        totalTransactions: 1\n                    }\n                }\n            });\n        });\n    }\n    let recievedFeeTransfers = {};\n    if ( query_data ){\n        query_data.blocks.nodes.forEach(node => {\n            let creator = node.creator\n            node.transactions.feeTransfer.forEach(transfer => {\n                let key = creator + transfer.recipient\n                if ( key in recievedFeeTransfers ){\n                    recievedFeeTransfers[key].totalFees += parseInt(transfer.fee)\n                    recievedFeeTransfers[key].totalTransfers += 1\n                }\n                else {\n                    recievedFeeTransfers[key] = {\n                        totalFees: parseInt(transfer.fee), \n                        to: transfer.recipient, \n                        from: creator,\n                        totalTransfers: 1\n                    }\n                }\n            })\n        })\n    }    \n\n    let txKeys = Object.keys(receivedTransactions)\n\n    // Compute New Nodes\n    const observedKeys = txKeys.map((txKey) => {\n        let tx = receivedTransactions[txKey]\n        return [tx.source, tx.target]\n    }).flat()\n\n    \n\n    const dedupedKeys = observedKeys.filter(function(item, pos) {\n        return observedKeys.indexOf(item) == pos;\n    })\n\n    //console.log(\"dedupedKeys: \", observedKeys)\n\n    const newKeys = dedupedKeys.filter((key) => {\n        return !(key in nodeIndex)\n    })\n\n    const newNodes = newKeys.map(key => {\n        return {\n            id: key, \n            name: knownKeys[key],\n            publicKey: key,\n        }\n    })\n\n    // Compute New Links\n    const observedLinks = Object.values(receivedTransactions)\n\n    const newLinks = observedLinks.filter((link) => {\n        const key = link.source + link.target\n        return !(key in linkIndex)\n    })\n    // console.log(\"linkIndex\", linkIndex)\n    // console.log(\"newLinks\", newLinks)\n    // console.log(\"nodeIndex\", nodeIndex)\n    // console.log(\"newNodes\", newNodes)\n\n    // Add New Nodes\n    if ( newNodes ){\n        newNodes.forEach(newNode => {\n            setData(({nodes, links}) => {\n                setNodeIndex((index) => {\n                    index[newNode.id] = nodes.length\n                    return index\n                })\n                return {\n                    nodes: [...nodes, newNode],\n                    links: links\n                }\n            })\n        })\n    }\n\n    // Add New Links\n    if ( newLinks ) {\n        newLinks.forEach(link => {\n            if ( link.target in nodeIndex && link.source in nodeIndex ){\n                setData(({nodes, links}) => {\n                    setLinkIndex((index) => {\n                        index[link.id] = links.length\n                        return index\n                    })\n                    return {\n                        nodes: nodes,\n                        links: [...links, link]\n                    }\n                })\n            }\n        })\n    }\n        \n\n    // Check if data has Updated\n    \n    \n//    const newTransactions = receivedTransactions.filter((new_tx) => {\n//         return !data.links.some(link => link.id === new_tx.id)\n//     })\n\n    // \n\n    \n\n    \n    \n\n    // function dedupeBy(values, by) {\n    //     const discriminant = {}\n    //     for (const value of values) {\n    //         const key = by(value)\n    //         if (!key in discriminant) {\n    //             discriminant[key] = value\n    //         }\n    //     }\n    //     return Object.values(discriminant)\n    // }\n\n    // if we have new data to set\n    // if (newTransactions.length !== 0) {\n    //     const allGraphNodes = Object.values(receivedTransactions).map((tx) => {\n    //         return [\n    //             {\n    //                 id: tx.from,\n    //                 name: tx.from,\n    //             },\n    //             {\n    //                 id: tx.to,\n    //                 name: tx.to,\n    //             }\n    //         ]\n    //     }).flat()\n\n    //     const graphNodes = dedupeBy(allGraphNodes, (node) => node.id)\n\n    //     const allNodes = data.nodes.concat(graphNodes)\n\n    //     const newLinks = newTransactions.map((tx) => {\n    //         return {\n    //             source: tx.from, \n    //             target: tx.to,\n    //             id: tx.id,\n    //             totalAmount: tx.amount, \n    //             totalNumber: tx.totalTransactions\n    //         } \n    //     }).filter(link => {\n    //       return allNodes.some(node => {\n    //         return node.id === link.target || node.id === link.source\n    //       })\n    //     })\n\n    //     const newData = {\n    //         links: data.links.concat(newLinks),\n    //         nodes: allNodes\n    //     }\n\n    //     setData(newData)\n    // }\n\n        // query_data.blocks.nodes.forEach((node) => {\n        //     const graph_node = { \n        //         id: node.stateHash, \n        //         name: node.stateHash,\n        //         value: node.stateHash\n        //     }\n        //     const link = {\n        //          source: node.stateHash, \n        //          target: node.protocolState.previousStateHash \n        //     } \n\n        //     if ( !data.nodes.some(node => node.id == new_node.id ) ) new_payload.nodes.add(new_node)\n            \n        //     if ( new_payload.nodes.some(node => node.id == link.target) || prev_data.nodes.some(node => node.id == link.target) ){\n        //         new_payload.links.add(link)\n        //     }   \n        // });\n    function normalize(val, max, min) { return (val - min) / (max - min); }\n\n    return <ForceGraph2D\n    ref={fgRef}\n    enableNodeDrag={true}\n    nodeLabel={(node) => {\n        return `Discord: ${node.name} </br>\n        Public Key: ${node.publicKey.substring(0,8)}\n        `\n    }}\n    //    return (\n    //        <div>\n    //            <p>\n    //                foo\n    //                {node.name.substring(0,8)}\n    //            </p>\n    //        </div>\n    //    )\n    //}}\n    linkCurvature={0.25}\n    linkDirectionalArrowLength={5}\n    linkWidth={(link) => {\n        const nTx = link.totalTransactions\n        if (nTx < 5) return 1\n        if (nTx < 10) return 2\n        if (nTx < 20) return 3\n        if (nTx < 50) return 4\n        if (nTx < 100) return 5\n        if (nTx < 150) return 6\n        // const nSent = link.totalSent\n        // if (nSent <= 100) return 1\n        // if (nSent < 250) return 2\n        // if (nSent < 500) return 3\n        // if (nSent < 800) return 4\n        // if (nSent < 1000) return 5\n        // if (nSent < 1500) return 6\n        return 10\n    }}\n    linkColor={(link) => {\n        let max = 400;\n        let rainbow = new Rainbow(); \n        rainbow.setNumberRange(0, 750);\n        rainbow.setSpectrum(\"grey\", \"green\", \"yellow\", \"orange\", \"red\");\n        return \"#\" + rainbow.colourAt(link.totalSent);\n    }}\n    graphData={data}\n    />;\n};\n\nconst GET_BLOCKS = gql`\nquery MyQuery {\n    blocks(first: 500) {\n      nodes {\n        transactions {\n          feeTransfer {\n            fee\n            recipient\n          }\n          userCommands {\n            fee\n            from\n            to\n            id\n            amount\n          }\n        }\n        creator\n      }\n    }\n}`\n\nexport default DynamicGraph","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport DynamicGraph from './transactions/transactions';\nimport Legend from './transactions/legend';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <DynamicGraph>\n        {/* <Blocks/> */}\n      </DynamicGraph>\n      \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ApolloProvider } from 'react-apollo';\n\nimport client from './client';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}